# Домашнє завдання: Рекурсія та алгоритми

Цей репозиторій містить три завдання з рекурсивних алгоритмів та обробки файлів.

---

## Завдання 1: Рекурсивне копіювання та сортування файлів

**Файл:** `01_copy_and_sort_file.py`

### Опис

Програма рекурсивно копіює файли з вихідної директорії та сортує їх у цільовій директорії за розширеннями файлів.

### Використання

```bash
python3 01_copy_and_sort_file.py <вихідна_директорія> [цільова_директорія]
```

**Параметри:**
- `вихідна_директорія` (обов'язково) - шлях до директорії, яку потрібно скопіювати
- `цільова_директорія` (опціонально) - шлях до директорії призначення (за замовчуванням: `dist`)

**Приклади:**

```bash
# Копіювання в директорію dist (за замовчуванням)
python3 01_copy_and_sort_file.py ./source_folder

# Копіювання в вказану директорію
python3 01_copy_and_sort_file.py ./source_folder ./my_backup
```

### Принцип роботи

1. Рекурсивно обходить всі файли та підпапки у вихідній директорії
2. Для кожного файла визначає розширення (наприклад, `.txt`, `.jpg`)
3. Створює відповідну підпапку в цільовій директорії
4. Копіює файл у відповідну підпапку
5. Файли без розширення поміщаються в папку `no_extension`

### Обробка помилок

- Перевіряє доступність вихідної та цільової директорій
- Обробляє помилки копіювання окремих файлів
- Виводить інформаційні повідомлення про процес копіювання

---

## Завдання 2: Сніжинка Коха

**Файл:** `02_koch_snowflake.py`

### Опис

Програма малює фрактал "Сніжинка Коха" за допомогою рекурсивного алгоритму та бібліотеки `turtle`.

### Використання

```bash
python3 02_koch_snowflake.py [рівень_рекурсії]
```

**Параметри:**
- `рівень_рекурсії` (опціонально) - глибина рекурсії для фракталу (за замовчуванням: 3)

**Приклади:**

```bash
# Малювання з рівнем 3 (за замовчуванням)
python3 02_koch_snowflake.py

# Малювання з рівнем 5
python3 02_koch_snowflake.py 5
```

### Алгоритм

**Крива Коха:**
1. Якщо рівень = 0, малюємо пряму лінію
2. Інакше ділимо лінію на 3 частини та:
   - Малюємо першу третину
   - Повертаємо на 60° вліво
   - Малюємо другу третину
   - Повертаємо на 120° вправо
   - Малюємо третю третину
   - Повертаємо на 60° вліво
   - Малюємо четверту третину

**Сніжинка Коха:**
- Складається з трьох кривих Коха, розташованих під кутом 120° одна до одної

### Особливості

- Використовує рекурсію для створення фрактальної структури
- Чим більший рівень рекурсії, тим детальніший фрактал
- Рекомендовані значення: 0-6 (вищі значення можуть працювати повільно)

---

## Завдання 3: Ханойські вежі

Рекурсивна реалізація класичної головоломки "Ханойські вежі" з візуалізацією в консолі.

## Опис

Програма виконує переміщення дисків з стрижня А на стрижень С, використовуючи стрижень В як допоміжний. Диски мають різний розмір і розміщені на початковому стрижні у порядку зменшення розміру зверху вниз.

### Правила

1. За один крок можна перемістити тільки один диск
2. Диск можна класти тільки на більший диск або на порожній стрижень

## Використання

```bash
python3 03_tower_of_hanoi.py [кількість_дисків]
```

**Параметри:**
- `кількість_дисків` (опціонально) - кількість дисків на початковому стрижні (за замовчуванням: 3)

**Приклади:**

```bash
# Запуск з 3 дисками (за замовчуванням)
python3 03_tower_of_hanoi.py

# Запуск з 5 дисками
python3 03_tower_of_hanoi.py 5
```

## Алгоритм

Програма використовує рекурсивний алгоритм "розділяй і володарюй":

1. Перемістити `n-1` дисків з джерела на допоміжний стрижень
2. Перемістити найбільший диск з джерела на цільовий стрижень
3. Перемістити `n-1` дисків з допоміжного стрижня на цільовий

**Базовий випадок:** якщо `n = 1`, просто переміщуємо диск з джерела на ціль.

## Структура коду

### Класи

**`HanoiVisualizer`**
- Відповідає за візуалізацію стану веж у консолі
- Малює диски символом `█` з центруванням
- Показує підписи стрижнів (A, B, C)

**`TowerOfHanoi`**
- Основний клас для розв'язання головоломки
- Зберігає стан веж у словнику
- Реалізує рекурсивний алгоритм у методі `run()`
- Збирає результати виконання для виводу

### Методи

- `run(n, source, target, auxiliary)` - рекурсивний метод розв'язання
- `_execute_move(source, target)` - виконує переміщення одного диска
- `solve_and_visualize()` - запускає алгоритм та повертає результат
- `draw()` - малює поточний стан веж

## Приклад виводу

```
Початковий стан: {'A': [3, 2, 1], 'B': [], 'C': []}
   █       |       |    
  ███      |       |    
 █████     |       |    
   A       B       C    

Перемістити диск з A на C: 1
Проміжний стан: {'A': [3, 2], 'B': [], 'C': [1]}
   |       |       |    
  ███      |       |    
 █████     |       █    
   A       B       C    

...

Кінцевий стан: {'A': [], 'B': [], 'C': [3, 2, 1]}
   |       |       █    
   |       |      ███   
   |       |     █████  
   A       B       C
```

## Складність

- **Часова складність:** O(2^n) - кількість ходів дорівнює 2^n - 1
- **Просторова складність:** O(n) - глибина рекурсії

## Автор

Реалізація виконана як частина домашнього завдання з алгоритмів.